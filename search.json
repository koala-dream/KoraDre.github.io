[{"url":"/2026/02/09/GT911%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/","content":"控制寄存器：0x8040\n配置寄存器（组）：0x8047-0x8100\n状态寄存器：0x814E\n坐标寄存器（组）：0x8150-0x8177\n\n写i2c通信框架，能够读到GT911芯片的ID号（需要参考手册，看看ID号在哪个寄存器里）\n坐标寄存器中含有Product ID信息，读出来很有可能是“911”\n\n\n\n"},{"url":"/2026/02/09/input%E5%AD%90%E7%B3%BB%E7%BB%9F/","content":"输入子系统-input关键数据结构\nstruct input_dev &#123;\tconst char *name;\t\t\t\t\t// 设备名字（需要）\tconst char *phys;\t\t\t\t\t// 设备的物理路径名字？（不重要）\tconst char *uniq;\t\t\t\t\t// 设备的唯一标识符（不重要）\tstruct input_id id;\t\t\t\t\t// 设备ID（不重要）\tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];\t// 设备属性位图（比较复杂）    \t/* 表示这个设备能够上报哪些类型的事件，使用前需要提前配置好 */\tunsigned long evbit[BITS_TO_LONGS(EV_CNT)];\t\t// 事件类型位图（重要）\tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\t\t// 事件码位图（重要）\tunsigned long relbit[BITS_TO_LONGS(REL_CNT)];\t\t// 相对坐标事件码位图（如何使用？）\tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\t\t// 绝对坐标事件码（重要）\tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\t\t// 杂项事件位图（如何使用？）\tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)];\t\t// LED指示灯位图（如何使用？）\tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)];\t\t// 声音事件位图（如何使用？）\tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)];\t\t// 力反馈事件位图（游戏手柄震动？）\tunsigned long swbit[BITS_TO_LONGS(SW_CNT)];\t\t// 开关事件位图（重要）        struct input_absinfo *absinfo;\t\t\t\t// 绝对坐标事件的信息配置        struct input_mt *mt;\t\t\t\t\t// 用于多点触摸管理        struct device dev;\t\t\t\t\t// 表示input框架所绑定的物理输入设备    \tunsigned long key[BITS_TO_LONGS(KEY_CNT)];\t\t// 按键状态位图，描述按键是否按下\tunsigned long led[BITS_TO_LONGS(LED_CNT)];\t\t// 同理\tunsigned long snd[BITS_TO_LONGS(SND_CNT)];\t\t// 同理\tunsigned long sw[BITS_TO_LONGS(SW_CNT)];\t\t// 同理    \t/* 内核自动管理，APP使用 */\tint (*open)(struct input_dev *dev);\tvoid (*close)(struct input_dev *dev);\tint (*flush)(struct input_dev *dev, struct file *file);\tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);    /*********************以下不是特别重要，大部分属于内核自动管理*******************/    .......&#125;;"},{"title":"USB基础知识","url":"/2026/02/05/usb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"设备枚举阶段-usb设备插入电脑后会做的事情\n\n\n当一个usb设备，比如说u盘，插到Linux板子里后，它的地址会被强制配置成0，pc不知道这个设备的具体地址，就会去0地址处寻找，又因为整个usb链路上只有这个新加入的usb设备地址是0，所以就可以以此访问它\n\n通过对0地址的配置，读取，pc会为这个新加入的设备分配一个id号（每一个usb设备有一个id号，范围是1-127）\n\n这个被分配出来的id号，就是令牌包、数据包里的7为地址！系统通过这个地址寻找到设备！\n\n\n具体过程如下：USB设备插入板卡后，Linux系统会做的事情\nUSB接口两根线电平发生变换，会被内核usb控制器驱动程序感知到，在hub_thread中去读取设备描述符，配置描述符\n\n通过读取到的设备描述符，配置描述符，usb控制器驱动程序就知道这个设备是什么设备\n\n系统会根据之前获得的 “三要素”（类代码、厂商ID、产品ID），去匹配被编译进内核的驱动程序\n\n匹配到驱动后，在probe函数里可能会去做各种事情，比如说注册进input子系统，或者作为块设备（u盘）注册，注册使用接口\n\n\n","categories":["Linux USB驱动"],"tags":["USB"]},{"title":"I2C基础知识","url":"/2026/01/26/2026-1-26-I2C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"简述I2C总线的基本原理。 (提示：两线制、同步、半双工、多主多从、地址寻址)\n\n(1)     IIC使用SCL和SDA两根线，SCL用于同步，SDA负责数据传输\n(2)    是半双工机制（主从机之间不能同时传输数据。）\n(3)    IIC是多主多从的协议\n(4)    地址寻址可以要么7位地址，要么10位地址\n🔴 重要内容\n\n为什么I2C总线需要上拉电阻？其阻值如何选择？(1)    因为需要实现多从机的机制，IIC的引脚需要使用开漏模式挂载到IIC总线上，开漏模式下的高电平由上拉电阻实现。如果不使用开漏输出模式，当主机访问从机1时，从机1拉低总线电平，而从机2会输出高电平，表示不应答，但是这样的话，会使得总线短路。开漏模式下，从机2释放总线（输出高阻态），不会影响到从机1的拉低，因为上拉电阻的存在，总线不会短路。\n(2)    根据IIC协议的速度需求选择阻值\nstruct power_supply_config &#123;    struct device_node *of_node;  // 设备节点    struct fwnode_handle *fwnode; // fwnode 节点    void *drv_data; // 私有数据    const struct attribute_group **attr_grp; // 私有的属性节点    char **supplied_to;  // 一个字符串数组, 保存了该 psy 向下一级供电的 psy 列表. 组织 psy 之间的级联方向.    size_t num_supplicants;    ANDROID_KABI_RESERVE(1);&#125;;\n\n\n\n详细描述I2C通信的时序：起始条件、停止条件、数据有效性及应答机制。(1)    起始信号：当SCL处于高电平时，SDA给出从高到低的下降沿电平\n(2)    停止信号：当SCL处于高电平时，SDA给出从低到高的上升沿电平\n(3)    当SCL处于低电平时，可以改变SDA的值，SCL处于高电平时，可以进行采样\n(4)    在接收完一帧数据后，从机&#x2F;主机应当选择拉低SDA总线进行应答，如果选择不应答，释放总线。\n什么是重复起始条件？它有什么作用？(1)    在不结束一次通讯的情况下，再次发起起始信号，但是这个重复起始信号的发起和起始信号不完全相同，因为在主机发送完一帧数据，从机应答后，SDA处于低电平状态，主机将SCL从高电平拉到低电平。这时，需要绕过终止信号，所以SCL需要先被拉低，然后拉高SDA，之后再拉高SCL（终于绕过终止信号，恢复到初始状态了，两个都为高电平），这个时候再发起始信号，就是一次完整的重复起始条件了。\n(2)    可以进行由写指令到读指令的转化。\nI2C支持哪些速率模式？实际选择时考虑哪些因素？I2C的地址有几位？7位地址的可用范围是多少？什么是保留地址？(1)    7位或者10位\n(2)    理论上是0-127，总共是128个地址。\n(3)    是一些特殊功能的地址，比如说复位功能，广播功能。\n为什么I2C要求使用开漏输出，而不能用推挽输出？ (需理解总线冲突、短路风险、多主机仲裁)I2C总线上最多能连接多少个设备？实际限制是什么？ (提示：地址空间限制 vs 总线电容负载限制)解释什么是“时钟拉伸”。它是如何工作的？有什么作用？I2C总线的最大传输距离受哪些因素影响？如何优化？I2C如何实现多主机通信？详细解释总线仲裁和时钟同步机制。如果总线上有两个从设备地址相同，会发生什么？如何解决？主机发送地址0x50和主机发送地址0x52同时发起通信，谁将赢得仲裁？请按位分析过程。比较I2C与SPI协议的优缺点。在什么场景下优先选择I2C？列举I2C通信中常见的故障及解决方法（如总线死锁、ACK丢失、时序问题等）。如果发现I2C通信不稳定，你的调试步骤是什么？会使用什么工具？ (如示波器、逻辑分析仪)描述一次你调试I2C总线问题的实际经历，包括问题现象、分析思路和最终解决方案。 (这是展现你工程能力的绝佳机会)","categories":["Linux I2C驱动"],"tags":["I2C"]}]